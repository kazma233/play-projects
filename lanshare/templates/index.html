<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <title>LanConnector</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/pico.min.css">
    <style>
        .text-center {
            text-align: center;
        }

        .inline-block {
            display: inline-block;
        }

        .pa10 {
            padding: 10px;
        }

        .m-10 {
            margin: 10px;
        }

        .m2 {
            margin: 2px;
        }

        .flex {
            display: flex;
        }

        .flex-align-center {
            align-items: center;
        }

        .flex-align-start {
            align-items: flex-start;
        }

        .flex-column {
            flex-direction: column;
        }

        .flex-content-center {
            justify-content: center;
            flex-wrap: wrap;
        }

        .object-contain {
            object-fit: contain;
        }

        .h-full {
            height: 100%;
        }

        .max-w-min {
            max-width: min-content;
        }

        .td-middle {
            vertical-align: center;
        }

        .td-nowrap {
            white-space: nowrap;
        }

        .td-wrap {
            word-wrap: break-word;
            white-space: normal;
            overflow-wrap: anywhere;
        }
    </style>
</head>

<body>

<div class="container" id="app">
    <header class="flex flex-content-center flex-column pa10">
        <div class="flex flex-content-center">
            <h1>LanConnector</h1>
        </div>
        <div class="flex flex-content-center">
            <p>æ‰«ç è®¿é—®</p>
        </div>
        <div class="flex flex-content-center">
            <div id="qrcode"/>
        </div>
    </header>

    <main>
        <section class="m-10">
            <form @submit.prevent="addItem">
                <fieldset role="group">
                    <input type="text" v-model.trim="content" placeholder="è¾“å…¥æ–‡æœ¬å‘é€..." required>
                    <input type="submit" value="ä¿å­˜"/>
                </fieldset>
            </form>

            <form @submit.prevent="doUploadFile">
                <fieldset role="group">
                    <input type="file" ref="fileInput" @change="uploadChanged">
                    <input type="submit" :disabled="uploading" value="ä¸Šä¼ "/>
                </fieldset>
            </form>
        </section>

        <hr>

        <section>
            <div class="flex flex-align-start">
                <h2>æ¶ˆæ¯åˆ—è¡¨ï¼š</h2>
            </div>
            <table>
                <thead data-theme="dark">
                <tr>
                    <th>ç±»å‹</th>
                    <th>å†…å®¹</th>
                    <th>æ“ä½œ</th>
                </tr>
                </thead>
                <tbody>
                <tr v-for="item in items" :key="item.id">
                    <td v-if="item.type === 'text'" class="td-middle td-nowrap">{{`ğŸ“„${item.type}`}}</td>
                    <td v-else class="td-middle td-nowrap">{{`ğŸ”—${item.type}`}}</td>

                    <td class="td-wrap">{{item.content}}</td>

                    <td class="td-middle td-nowrap">
                        <button class="m2" @click="removeItem($event, item.id)">åˆ é™¤</button>
                        <button class="m2" v-if="item.type === 'text'" @click="copyContent(item.content)">å¤åˆ¶</button>
                        <a class="m2" v-else :href="`/download/${item.id}`" target="_blank">
                            <button>æ‰“å¼€</button>
                        </a>
                    </td>
                </tr>
                </tbody>
            </table>
        </section>
    </main>
</div>

</body>

<script src="/js/vue.global.min.js"></script>
<script src="/js/axios.min.js"></script>
<script src="/js/qrcode.min.js"></script>
<script>
    async function requestClipboardPermission() {
        try {
            const permissionStatus = await navigator.permissions.query({name: 'clipboard-write'});
            console.log(`å‰ªè´´æ¿æƒé™çŠ¶æ€: ${permissionStatus.state}`);
            return permissionStatus.state;
        } catch (err) {
            console.error('è¯·æ±‚å‰ªè´´æ¿æƒé™å¤±è´¥: ', err);
            return 'error';
        }
    }

    const {createApp, ref} = Vue
    createApp({
        setup() {
            return {}
        },
        data() {
            return {
                items: ref([]),
                content: ref(''),
                uploadFiles: null,
                uploading: false,
            }
        },
        methods: {
            async fetchItems() {
                try {
                    const response = await axios.get("/msg");
                    this.items = response.data;
                } catch (error) {
                    console.error('è·å–æ¶ˆæ¯åˆ—è¡¨å¤±è´¥:', error);
                }
            },
            async addItem(event) {
                event.preventDefault();
                if (!this.content.trim()) return;

                try {
                    await axios.post("/msg", {type: "text", content: this.content});
                    await this.fetchItems();
                    this.content = '';
                } catch (error) {
                    console.error('æ·»åŠ æ¶ˆæ¯å¤±è´¥:', error);
                }
            },
            async removeItem(event, id) {
                event.preventDefault();
                try {
                    await axios.delete(`/msg/${id}`);
                    await this.fetchItems();
                } catch (error) {
                    console.error('åˆ é™¤æ¶ˆæ¯å¤±è´¥:', error);
                }
            },
            uploadChanged(event) {
                this.uploadFiles = event.target.files;
            },
            async doUploadFile(event) {
                event.preventDefault();
                if (!this.uploadFiles?.[0] || this.uploading) return;

                this.uploading = true;
                const form = new FormData();
                form.append('file', this.uploadFiles[0]);

                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

                    await axios.post('/fs', form, {
                        signal: controller.signal,
                        headers: {
                            'Content-Type': 'multipart/form-data'
                        },
                        onUploadProgress: (progressEvent) => {
                            const percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);
                            console.log(`Upload progress: ${percentCompleted}%`);
                        }
                    });

                    clearTimeout(timeoutId);
                    await this.fetchItems();
                    this.$refs.fileInput.value = null;
                } catch (error) {
                    console.error('ä¸Šä¼ æ–‡ä»¶å¤±è´¥:', error);
                    let errorMessage = 'ä¸Šä¼ æ–‡ä»¶å¤±è´¥';

                    if (error.code === 'ERR_CONNECTION_RESET') {
                        errorMessage = 'è¿æ¥è¢«é‡ç½®ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥æ˜¯å¦æ­£å¸¸';
                    } else if (error.code === 'ERR_NETWORK') {
                        errorMessage = 'ç½‘ç»œè¿æ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
                    } else if (error.code === 'ECONNABORTED') {
                        errorMessage = 'ä¸Šä¼ è¶…æ—¶ï¼Œè¯·é‡è¯•';
                    } else if (error.response) {
                        // å¤„ç†æœåŠ¡å™¨è¿”å›çš„é”™è¯¯ä¿¡æ¯
                        if (error.response.data && error.response.data.error) {
                            errorMessage = `ä¸Šä¼ å¤±è´¥: ${error.response.data.error}`;
                        } else {
                            errorMessage = `æœåŠ¡å™¨é”™è¯¯ (${error.response.status}): ${error.response.statusText || 'æœªçŸ¥é”™è¯¯'}`;
                        }
                    }

                    alert(errorMessage);
                } finally {
                    this.uploading = false;
                }
            },
            async copyContent(text) {
                try {
                    const permissionStatus = await requestClipboardPermission();
                    if (permissionStatus === 'granted' || permissionStatus === 'prompt') {
                        await navigator.clipboard.writeText(text);
                        console.log(`å·²å¤åˆ¶ "${text}" åˆ°å‰ªè´´æ¿`);
                    } else {
                        const tempElement = document.createElement('textarea');
                        tempElement.value = text;
                        document.body.appendChild(tempElement);
                        tempElement.select();
                        document.execCommand('copy');
                        document.body.removeChild(tempElement);
                        console.log(`å·²å¤åˆ¶ "${text}" åˆ°å‰ªè´´æ¿`);
                    }
                } catch (err) {
                    console.error('å¤åˆ¶æ–‡æœ¬å¤±è´¥: ', err);
                    alert('å¤åˆ¶æ–‡æœ¬å¤±è´¥');
                }
            },
        },
        mounted() {
            this.fetchItems();


            var qrcode = new QRCode(document.getElementById("qrcode"), {
                text: window.location.href,
                width: 200,
                height: 200,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
        }
    }).mount('#app')
</script>

</html>